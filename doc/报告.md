## Simple+ 语言的语法分析器

[TOC]

### 本语法分析器实现的功能
本程序使用Python编码实现，词法分析采用了沿用了作业一的代码，语法分析实现的功能有：
 - 利用文法推导式构造LR(1)分析表
 - 使用LR(1)分析表对输入的Token串进行语法分析，构建语法树
 - 在构建语法树的时候进行一些标识符类型的识别
 - 树形输出语法树，可视化输出语法树构建过程
 - 词法语法检错，人性化的错误提示

### 程序运行结果

在控制台进入项目目录，使用以下几条命令运行程序
1. `python3 main.py src_path [show-tree-animation] [show-simplify-tree]`
2. `python3 main.py make-parse-table`
3. `python3 main_c.py c_src_path`

命令2用来构造语言的LR(1)语法分析表，并将分析表以文件的形式保存到项目目录的`data`文件夹中；
命令1用来对输入路径为`src_path`的源文件进行语法分析，选项`show-tree-animation`用于开启可视化输出语法树构建过程，选项`show-simplify-tree`设置输出简化版的语法树(简化规则下文有说明)
命令3可以对C语言源程序进行语法分析并生成语法分析树，但程序词法分析所接受的Token为标准C语言的子集(比如不支持读入`5e-5`形式的浮点数)

下面为语法分析器对以下源程序进行语法分析的结果
```pascal
program sample
constant 
    pi=3.1415926;
    e=2.71828182;
var 
    a : array[2] of integer;
    b : integer;
procedure show(a:char) begin
	call writeln(a)
end
begin
    a[0] := 1;
    a[1] := pi + 1;
    b := e * 100;
    if a or b then
		call writeln('a or b is true')
	else
		call writeln('all false')
end
```
程序语法树构造结果截图(原始图片见附件)：
![Alt text](./simple_parse_tree.png)
加入`show-tree-animation`选项开启动画效果输出的程序运行过程:
[![asciicast](https://asciinema.org/a/9PJfaMi7TqzxgjkGiI9opkldB.svg)](https://asciinema.org/a/9PJfaMi7TqzxgjkGiI9opkldB)

经过符号类型识别后符号表的内容：
![Alt text](./doc/assets/3.png)

源文件存在词法错误时的输出：
![Alt text](./doc/assets/4.png)

源文件存在语法错误时的输出：
![Alt text](./doc/assets/5.png)

以下为程序对项目下二分搜索C程序`binary_search.c`进行语法分析所得的语法树(原始图片见附件)：
![Alt text](./c_parse_tree_simplified.png)


### 程序实现
#### 项目结构及说明
```
.
├── main.py   # Simple+语言语法分析程序
├── main_c.py # C语言语法分析程序
├── c_langage
│   ├── c.py
│   ├── __init__.py
│   ├── scanner.py  # C语言词法分析模块
│   └── symbol.py   # C语言词法符号
├── data
│   ├── c_parse_table.dat    # C语言语法分析表
│   └── LR1_parse_table.dat  # Simple+语言语法分析表
├── doc
│   └── bnf_syntax_of_c.txt  #  C语言语法BNF推导式
├── parser
│   ├── __init__.py
│   ├── lr1.py       #  LR(1)语法分析模块
│   ├── symbol.py    
│   └── tools.py     #  求First集，Nullable集，Clusure集和GOTO的函数
├── scanner
│   ├── __init__.py 
│   └── scanner.py   # Simple+语言词法分析模块
├── binary_search.c  # C语言语法分析示例程序
├── text1.simple     # Simple+语言语法分析示例程序
└── text2.simple     # Simple+语言语法分析示例程序
```

#### 词法分析模块 
本程序词法分析模块(`scanner/scanner.py`)沿用作业一的代码，并在其基础上进行了修改，以满足语法分析器的输入要求，修改部分有：
将Token抽象成类，成员变量有`terminal value line_no`，分别表示该Token的终结符、Token值(对于常数保存其值，对于标识符保存其在符号表中的索引，对于字符串保存其在字符串表中的索引)、Token所在源文件的行号。

将符号表中的符号抽象成`Symbol`类表示，成员有标识符名称、 标识符类型、数组类型和维数 （如果当前符号类型为数组）、过程参数表 （如果当前符号类型为过程），常量类型和常量值 （如果当前符号类型为常量）。

引入异常`ScanError`表示词法分析阶段产生的错误，异常处理程序可以调用该异常的`show_error()`方法来显示错误输出。

####  语法分析表构造模块
模块路径：`parser/tools.py`，本模块可以根据输入的文法推导式列表计算其语法非终结符的FIRST集、NULLABLE集。可根据输入项集计算项集的闭包、计算GOTO转移状态，求取语法分析表。

模块中项的由类`Item`表示，其成员函数有`pid dot ahead`，`pid`为该项使用的推导式的编号，`dot`为项中点的位置，`ahead`为项的前看符号集合，这里项的表示和课上的表示略有区别，这里`ahead`变成了集合，这样，多个相同推导式并且点的位置相同的项可以合并。

以下选取计算项集的闭包和求取语法分析表两个函数进行分析：
![Alt text](./doc/assets/8.png)
函数先是计算出每个非终结符的推导式编号列表，用于在后面对待归约项目(形如`A-> α·Bβ`)进行展开时求取新项的推导式标号。然后遍历项集中每一项，如果项可展开(右部长度大于点的位置)且点后面为非终结符，这里以`A -> α·Bβ, (a,b,c,..)`为例，则开始求取展开项的前看符号的集合，即`FIRST(βa)+FIRST(βb)+FIRST(βc)+...`，然后对于待规约符号`B`的每个推导式`B -> α`,`B -> β`...，生成相应的项`B -> ·α, ahead`,`B -> ·β, ahead`加入项集中。

由于循环终止的条件是项集不发生改变，对此的实现为：设置一个标志变量`changing`表示本次迭代有没有对项集进行改变，在迭代中，对项集进行了实际的修改后，就将此变量置为真。

![Alt text](./doc/assets/9.png)
计算完项集闭包后还要对计算出的闭包进行冲突检查，判断是否存在规约-规约冲突和移入-规约冲突。

构造语法分析表的过程如下：
![Alt text](./doc/assets/11.png)

语法分析表既包含Action表又包含GOTO表，采用的数据结构为双层嵌套字典，外层字典的键为闭包编号(状态编号)，内层字典的键为终结符和非终结符，终结符键对应的值为原Action表中的前看符号为终结符时进行的操作(移入并转移状态/使用推导式进行规约)，非终结符对应的值为GOTO表中当前状态输入非终结符后转移的状态。

函数维护了一个待处理闭包的栈，首先程序计算增广文法第一个项的闭包，将其加入待处理闭包栈，然后开始while循环，直到待处理闭包栈为空。在每次循环体中，先取出栈顶未处理的闭包，遍历闭包的每一项：对于规约项，向语法分析表的相应位置填入规约动作和规约使用的推导表达式编号；对于移进项和待规约项，调用GOTO函数计算移进和规约之后项的闭包，判断新闭包是否已经存在，不存在则进行保存并将新闭包加入待处理闭包栈，之后更新语法分析表。

由于在计算闭包的时候已经判断了冲突，所以这里无需再进行冲突判断。

#### 语法分析模块
语法分析模块使用语法分析表进行语法分析，构造语法树。
![Alt text](./doc/assets/12.png)
程序采用双栈分保存状态和符号，并对符号栈进行特殊处理：每次弹栈时并不丢弃栈顶符号串，而是将他们作为新入栈符号的子节点，实质上符号栈就保存了当前生成的语法森林(多个子语法树)，最后规约到开始符号后，符号栈栈顶元素即为语法树。(这里语法树的构建过程就类似于Huffman树的构建过程。)

这里在每次规约之后，还调用了`type_recognize`函数进行类型识别，关于类型识别下文即有描述。

#### 符号类型识别模块
在语法分析阶段可以确定一些标识符的类型，本程序在构建语法树过程中对特定推导式进行规约时进行符号类型识别。
即，在对以下推导式进行规约时：
 - <常数定义>→<标识符>=<常数>;
 - <变量定义>→<标识符表>:<类型>;
 - <过程说明>→procedure<标识符>(<形参表>)<分程序>
 - <程序>→program<标识符><分程序>

可以确定推导式中<标识符>的类型。

![Alt text](./doc/assets/14.png)

该函数用到了两个工具函数：`simpify(node)`和`get_children(node)`，`simpify(node)`接受一个语法树，将只有一个子节点的内部节点忽略，比如有一个推导为`A -> B -> C -> abc`的语法树，`simpify(node)`将返回`A -> abc`;`get_children(node)`函数返回节点的端末节点。
> 语法分析程序的选项`show-simplify-tree`也是使用同样的方法化简语法树

以对`<变量定义>→<标识符表>:<类型>;`推导进行类型识别为例，讲述函数实现逻辑。

首先读取`<类型>`子树的信息，可能有简单类型和复合类型两种，调用`get_children(node)`函数找到`<标识符表>`子树的端末节点也就是标识符列表，更新符号栈中标识符对应的符号信息，设置符号类型为从`<类型>`子树读到的类型。

对于实例程序`text1.simple`，程序进行类型识别后，输出的符号表如下：
![Alt text](./doc/assets/16.png)
可以看到程序确定了大部分符号的类型和其他信息。

### 其他
#### C语言语法分析
程序使用写成的构建语法分析表的模块对C语言语法分析表进行了构建，从200多条推导式中构造出一张具有1800多个状态的语法分析表，并可以对C源程序进行语法分析。
对于C语言的语法和词法分析的实现，相对于Simple+语言仅有词法分析使用了不同的模块，也说明了本语法分析程序具有良好的可扩展性。

#### 文档错误
在进行Simple+语言的语法分析器编写过程中，发现了一些原`SIMPLE+语言的定义.doc`文档中的错误，在此列出：
1. while 关键字未列出
定义6里面定义的语言关键字未包含`while`，但是定义53给出的右部中却包含了`while`
> 解决： 将定义6中的`wgile`修改为`while`

2. <字符常量>未定义
定义28右部出现了`<字符常量>`符号，但是却没有在前文定义`<字符常量>`
> 解决： 将此处的`<字符常量>`符号修改为`<字符常数>`

3. == 未定义
定义55右部出现了`==`符号，但是却没有在前文定义,
> 解决： 将此处的`==`符号修改为`：=`

4. <因子> 定义逻辑错误
> 解决：定义21由`<因子>→<算术量>|<算术表达式>`改为`<因子>→<算术量>|(<算术表达式>)`

5. <变量定义> 定义错误
> 解决：定义35由`<变量定义>→<标识符表>:<类型>;|<标识符表>;<类型>;<变量定义>`改为`<变量定义>→<标识符表>:<类型>;|<标识符表>:<类型>;<变量定义>`

6.  <if 句>未定义
> 解决：定义49由`<结构句>→<复合句>|<if 句>|<while 句>|<for 句>|<repeat 句>`改为`<结构句>→<复合句>|<if 语句>|<while 句>|<for 句>|<repeat 句>`



